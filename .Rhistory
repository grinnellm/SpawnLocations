?read.csv
?read_csv
# Install missing packages and load required packages (if required)
UsePackages <- function( pkgs, locn="https://cran.rstudio.com/" ) {
# Reverse the list
rPkgs <- rev( pkgs )
# Identify missing (i.e., not yet installed) packages
newPkgs <- rPkgs[!(rPkgs %in% installed.packages( )[, "Package"])]
# Install missing packages if required
if( length(newPkgs) )  install.packages( newPkgs, repos=locn )
# Loop over all packages
for( i in 1:length(rPkgs) ) {
# Load required packages using 'library'
eval( parse(text=paste("suppressPackageStartupMessages(library(", rPkgs[i],
"))", sep="")) )
}  # End i loop over package names
}  # End UsePackages function
# Make packages available
UsePackages( pkgs=c("tidyverse", "sp", "maptools", "raster", "rgeos",
"scales", "ggforce", "plyr", "viridis", "shiny") )
?read_csv
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
spawnRaw
# Load spawn data
spawn <- read_csv( file=spawnLoc, col_types=cols(), guess_max=10000 ) %>%
group_by( Year, Region, StatArea, Section, LocationCode, SpawnNumber ) %>%
summarise( Eastings=unique(Eastings), Northings=unique(Northings),
SpawnIndex=sum(SurfSI, MacroSI, UnderSI) ) %>%
ungroup( )
spawn
# Load spawn data
spawn <- read_csv( file=spawnLoc, col_types=cols(), guess_max=10000 ) %>%
group_by( Year, Region, StatArea, Section, LocationCode, SpawnNumber ) %>%
summarise( Eastings=unique(Eastings), Northings=unique(Northings),
SpawnIndex=sum(SurfSI, MacroSI, UnderSI, na.rm=TRUE) ) %>%
ungroup( )
spawn
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
shapes
# Get spawn data
spawnSub <- CropSpawn( dat=spawn, locations=locCodes, yrSt=yrStart )
spawn
spawn %>% filter( is.na(Eastings))
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
spawnSub
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
runApp('Locations')
shiny::runApp()
runApp()
shiny::runApp()
runApp()
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
# General options
rm( list=ls( ) )      # Clear the workspace
sTime <- Sys.time( )  # Start the timer
graphics.off( )       # Turn graphics off
# Install missing packages and load required packages (if required)
UsePackages <- function( pkgs, locn="https://cran.rstudio.com/" ) {
# Reverse the list
rPkgs <- rev( pkgs )
# Identify missing (i.e., not yet installed) packages
newPkgs <- rPkgs[!(rPkgs %in% installed.packages( )[, "Package"])]
# Install missing packages if required
if( length(newPkgs) )  install.packages( newPkgs, repos=locn )
# Loop over all packages
for( i in 1:length(rPkgs) ) {
# Load required packages using 'library'
eval( parse(text=paste("suppressPackageStartupMessages(library(", rPkgs[i],
"))", sep="")) )
}  # End i loop over package names
}  # End UsePackages function
# Make packages available
UsePackages( pkgs=c("tidyverse", "sp", "maptools", "raster", "rgeos",
"scales", "ggforce", "plyr", "viridis", "shiny") )
# General options
# locOpts <- list( Region="JS", Longitude=-126.496242, Latitude=50.797227 )  # Burwood
# locOpts <- list( Region="SoG", Longitude=-123.494499, Latitude=48.9070892 )  # Tricolmali
# locOpts <- list( Region="SoG", Longitude=-124.74, Latitude=49.55 )  # Denman
# locOpts <- list( Region="HG", Longitude=-131.9913, Latitude=53.2665 )  # Skidegate
# locOpts <- list( Region="CC", Longitude=-128.4934, Latitude=51.8665 )  # Goose Group
# locOpts <- list( Region="SoG", Longitude=-123.1558, Latitude=49.2078 )  # Fraser
locOpts <- list( Region="SoG", Longitude=-123.3144, Latitude=48.735 )  # Pender
# Saved R datafile (from Spawn.R)
spawnLoc <- file.path( "Data", "SpawnRaw.csv" )
# Input coordinate reference system (spill)
crsSpill <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
# Input coordinate reference system (herring sections)
crsSect <- "+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000
+y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
# Input coordinate reference system (land)
crsLand <- "+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000
+y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
# Input coordinate reference system (spawn)
crsSpawn <- "+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000
+y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
# Output coordinate reference system (BC Albers)
crsOut <- "+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000
+y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
# Geographic projection
geoProj <- "Projection: BC Albers (NAD 1983)"
# Location of the BC stocks shapefiles
locStocks <- file.path( "Data", "Polygons", "SectionsIntegrated" )
# Location of the BC land file
locLand <- file.path( "Data", "Polygons", "GSHHS_h_L1_Alb" )
# Change default ggplot theme to 'black and white'
theme_set( theme_bw() )
# Modify default theme
myTheme <- theme(
legend.box.background=element_rect(fill=alpha("white", 0.7)),
legend.box.margin=margin(1, 1, 1, 1, "mm"),
legend.key=element_blank(), legend.margin=margin(), legend.text.align=1,
panel.grid.major=element_line(colour="darkgrey", size=0.2),
panel.grid.minor=element_line(colour="darkgrey", size=0.1),
legend.background=element_rect(fill="transparent"),
#panel.spacing.x=unit(3, "lines"),
plot.margin=unit(c(0.1, 0.6, 0.1, 0.1), "lines") )
# Figure width
figWidth <- 6
# Spill location
spillXY <- c( locOpts$Longitude, locOpts$Latitude )
# Buffer for the spill (m)
bufSpill <- 15000
# Buffer for the map (m)
bufMap <- 40000
# Conversion factors
convFacs <- list( nm2m=1852 )
# First year of data to consider (NA for all years)
yrStart <- NA
# Location codes to consider (NA for all locations)
locCodes <- NA # c( 1484, 0842, 1680, 1883, 1871, 0837, 1888, 0841, 1754 )
# Load spawn data
spawn <- read_csv( file=spawnLoc, col_types=cols(), guess_max=10000 ) %>%
group_by( Year, Region, StatArea, Section, LocationCode, SpawnNumber ) %>%
summarise( Eastings=unique(Eastings), Northings=unique(Northings),
SpawnIndex=sum(SurfSI, MacroSI, UnderSI, na.rm=TRUE) ) %>%
ungroup( ) %>%
filter( !is.na(Eastings), !is.na(Northings), !is.na(SpawnIndex) )
# Convert location to Albers
ConvLocation <- function( xy ) {
# Make a matrix
xyMat <- matrix( xy, ncol=2 )
# Convert to spatial points
xySP <- SpatialPoints( coords=xyMat, proj4string=CRS(crsSpill) )
# Transform to correct projection
xySP <- spTransform( x=xySP, CRSobj=CRS(crsOut) )
# Make a data frame
xyDF <- data.frame( xySP ) %>%
rename( Eastings=coords.x1, Northings=coords.x2 )
# Return the points
return( list(xySP=xySP, xyDF=xyDF) )
}  # End ConvLocation function
# Get the spill location
spill <- ConvLocation( xy=spillXY )
# Function to wrangle shapefiles
GetStocks <- function( stocks, land ) {
# Load the Section shapefile (has Statistical Areas and Regions)
secBC <- readShapePoly( fn=stocks, proj4string=CRS(crsSect) )
# Function to perform some light wrangling
UpdateSections <- function( dat ) {
# Some light wrangling
dat@data <- dat@data %>%
mutate( StatArea=as.character(StatArea),
Section=as.character(Section) ) %>%
select( SAR, StatArea, Section )
# Remove the non-SAR areas
res <- dat#[dat$Section %in% c(111, 112, 121:127, 131:136), ]
#    # Update the SAR
#    res$SAR <- 8
# Return updated sections
return( res )
}  # End UpdateSections function
# Update sections
secBC <- UpdateSections( dat=secBC )
# Project to BC
secBC <- spTransform( x=secBC, CRSobj=CRS(crsOut) )
# Get a buffer around the region(s) in question
buff <- gBuffer( spgeom=spill$xySP, width=bufMap, byid=FALSE )
# Calculate the extent
extBuff <- bbox( buff )
# Convert the extent to a table
extDF <- tibble( Eastings=extBuff[1, ], Northings=extBuff[2, ] )
# Determine x:y aspect ration (for plotting)
xyRatio <- diff(extDF$Eastings) / diff(extDF$Northings)
# Crop the sections
secBC <- crop( x=secBC, y=extBuff )
# Determine section centroids
secCent <- gCentroid( spgeom=secBC, byid=TRUE )
# Convert to data frame
secCentDF <- secCent %>%
as_tibble( ) %>%
rename( Eastings=x, Northings=y ) %>%
mutate( Section=formatC(secBC$Section, width=3, flag="0") ) %>%
arrange( Section )
# Convert to data frame and select stat areas in question
secDF <- secBC %>%
fortify( region="Section" ) %>%
rename( Eastings=long, Northings=lat, Section=group ) %>%
as_tibble( )
# Dissolve to stat area
saBC <- aggregate( x=secBC, by=list(Temp=secBC$StatArea), FUN=unique )
# Convert to data frame and select stat areas in question
saDF <- saBC %>%
fortify( region="StatArea" ) %>%
rename( Eastings=long, Northings=lat, StatArea=group ) %>%
as_tibble( )
# Read the polygon data: land
landSPDF <- readShapePoly( fn=land, proj4string=CRS(crsLand) )
# Transform
landSPDF <- spTransform( x=landSPDF, CRSobj=CRS(crsOut) )
# Clip the land to the buffer: big
landSPDF <- crop( x=landSPDF, y=extBuff )
# Convert to data frame
landDF <- landSPDF %>%
fortify( region="id" ) %>%
rename( Eastings=long, Northings=lat ) %>%
as_tibble( )
# Build a list to return
res <- list( secDF=secDF, secCentDF=secCentDF, saDF=saDF, landDF=landDF,
extDF=extDF, extBuff=extBuff, xyRatio=xyRatio )
# Return info
return( res )
}  # End GetStocks function
# Get stock shapefiles
shapes <- GetStocks( stocks=locStocks, land=locLand )
# Function to crop (spatially) spawn
CropSpawn <- function( dat, locations, yrSt ) {
# Remove missing coordinates
# dat <- dat %>%
#   filter( !is.na(Eastings), !is.na(Northings) ) %>%
#   group_by( Region, StatArea, Section, LocationCode, Eastings,
#     Northings, Year ) %>%
#   summarise(SurfSI=sum(SurfSI, na.rm=TRUE),
#     MacroSI=sum(MacroSI, na.rm=TRUE), UnderSI=sum(UnderSI, na.rm=TRUE),
#     SpawnIndex=sum(SurfSI, MacroSI, UnderSI, na.rm=TRUE) ) %>%
#   ungroup( )
# # If specific location codes are specified
# if( !all(is.na(locCodes)) )
#   dat <- dat %>%
#     filter( LocationCode %in% locations )
# # If specific years are specified
# if( !is.na(yrSt) )
#   dat <- dat %>%
#     filter( Year >= yrSt )
# Convert to a spatial object
coordinates( dat ) <- ~ Eastings+Northings
# Give the projection
crs( dat ) <- CRS( crsSpawn )
# Transform
datSP <- spTransform( x=dat, CRSobj=CRS(crsOut) )
# Clip to extent
datSP <- crop( x=datSP, y=shapes$extBuff )
# Make a data frame
dat <- data.frame( datSP ) %>%
as_tibble( ) #%>%
# mutate(
#   Decade=paste(round_any(x=Year, accuracy=10, f=floor), "s", sep=""),
#   Decade=ifelse(Decade == "NAs", NA, Decade) )
# Summarise by decade and XY
# datByDecadeXY <- datDF %>%
#   group_by( Eastings, Northings, Decade ) %>%
#   summarise( Number=n(), MeanSI=mean(SpawnIndex) ) %>%
#   ungroup( )
# Summarise by XY
# datByXY <- datDF %>%
#   group_by( Eastings, Northings ) %>%
#   summarise( Number=n(), MeanSI=mean(SpawnIndex) ) %>%
#   ungroup( )
# Return the data
return( dat )
# return( list(datSP=datSP, datDF=datDF, datByDecadeXY=datByDecadeXY,
#   datByXY=datByXY) )
}  # End CropSpawn function
# Get spawn data
spawnSub <- CropSpawn( dat=spawn, locations=locCodes, yrSt=yrStart )
# Function to crop (spatially) spawn
CropSpawn <- function( dat, locations, yrSt ) {
browser()
# Remove missing coordinates
# dat <- dat %>%
#   filter( !is.na(Eastings), !is.na(Northings) ) %>%
#   group_by( Region, StatArea, Section, LocationCode, Eastings,
#     Northings, Year ) %>%
#   summarise(SurfSI=sum(SurfSI, na.rm=TRUE),
#     MacroSI=sum(MacroSI, na.rm=TRUE), UnderSI=sum(UnderSI, na.rm=TRUE),
#     SpawnIndex=sum(SurfSI, MacroSI, UnderSI, na.rm=TRUE) ) %>%
#   ungroup( )
# # If specific location codes are specified
# if( !all(is.na(locCodes)) )
#   dat <- dat %>%
#     filter( LocationCode %in% locations )
# # If specific years are specified
# if( !is.na(yrSt) )
#   dat <- dat %>%
#     filter( Year >= yrSt )
# Convert to a spatial object
coordinates( dat ) <- ~ Eastings+Northings
# Give the projection
crs( dat ) <- CRS( crsSpawn )
# Transform
datSP <- spTransform( x=dat, CRSobj=CRS(crsOut) )
# Clip to extent
datSP <- crop( x=datSP, y=shapes$extBuff )
# Make a data frame
dat <- data.frame( datSP ) %>%
as_tibble( ) #%>%
# mutate(
#   Decade=paste(round_any(x=Year, accuracy=10, f=floor), "s", sep=""),
#   Decade=ifelse(Decade == "NAs", NA, Decade) )
# Summarise by decade and XY
# datByDecadeXY <- datDF %>%
#   group_by( Eastings, Northings, Decade ) %>%
#   summarise( Number=n(), MeanSI=mean(SpawnIndex) ) %>%
#   ungroup( )
# Summarise by XY
# datByXY <- datDF %>%
#   group_by( Eastings, Northings ) %>%
#   summarise( Number=n(), MeanSI=mean(SpawnIndex) ) %>%
#   ungroup( )
# Return the data
return( dat )
# return( list(datSP=datSP, datDF=datDF, datByDecadeXY=datByDecadeXY,
#   datByXY=datByXY) )
}  # End CropSpawn function
# Get spawn data
spawnSub <- CropSpawn( dat=spawn, locations=locCodes, yrSt=yrStart )
#   ungroup( )
# # If specific location codes are specified
# if( !all(is.na(locCodes)) )
#   dat <- dat %>%
#     filter( LocationCode %in% locations )
# # If specific years are specified
# if( !is.na(yrSt) )
#   dat <- dat %>%
#     filter( Year >= yrSt )
# Convert to a spatial object
coordinates( dat ) <- ~ Eastings+Northings
# Give the projection
crs( dat ) <- CRS( crsSpawn )
# Transform
datSP <- spTransform( x=dat, CRSobj=CRS(crsOut) )
# Clip to extent
datSP <- crop( x=datSP, y=shapes$extBuff )
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
runApp()
source('C:/Grinnell/Git/SpawnLocations/Locations.R')
runApp()
shiny::runApp()
runApp()
shiny::runApp()
